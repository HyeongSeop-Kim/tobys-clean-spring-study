## 개요
인프런 **토비의 클린 스프링** 강의 스터디 프로젝트.  
강의를 보면서 중요하다고 생각되거나 기억이 필요한 내용을 해당 파일에 정리하였음.

## 학습방법
- 강의 중간에 질문이 나오면, 멈추고 나라면 **어떤 것을 어떤 이유로 선택**할지 생각해보기
  - 질문에 대해 생각한 내용 글로 정리하기
- **자신만의 방식으로 접근**(브랜치 따는 등)해보고, 이후에 이 선택이 **어떤 영향**이 있는지 생각해보기

## 개발 환경 구성

### JDK
1. IDE의 JDK 다운로드 기능
2. JDK 배포판 웹사이트에서 다운로드 받아 설치
3. JDK 버전을 관리하는 도구를 이용해서 설치
   - SDKMAN: Java와 다양한 도구의 버전 관리
   - jabba: Java 버전 관리
   - asdf: 다양한 프로그래밍 언어와 도구 관리
   - jvms: 윈도우용 JDK 버전 관리자

### IDE (Intergrated Development Environment)
IntelliJ 사용

### HTTPie

### MySQL

### Docker

## AI 개발 지원 도구
- GitHub Copilot (IntelliJ Plugin, github.com)
- ChatGPT
- Claude
- DeepSeek
- Perplexity <- 검색 적극 활용하여 출처, 공식문서 등 찾아줌
  
**새로운 기술 사용법을 익히거나 코딩 연습을 할 때는 AI를 꺼두자!**

## Docker Compose Support

---
## 도메인
- 소프트웨어 개발에서의 도메인: 사용자가 프로그램이나 소프트웨어 서비스를 적용하는 주제 영역
- 도메인은 현실 세계의 일부로 단순히 코드로 옮길 수 없다. 따라서, 도메인의 추상화인 도메인 모델을 만들어야 한다. 
  - 도메인에 존재하는 **중요한 개념과 이들 사이의 관계와 규칙**을 표현
- **도메인 주도 설계(Domain Driven Design)**
  - **도메인 모델을 개발 과정의 중심**에 두는 방법
  - 개발자 뿐 아니라 도메인을 잘 아는 이해 관계자가 모두 참여해 **도메인 모델을 만들고 발전시켜야** 한다.
  - 도메인 모델에 기반한 보편 언어를 정의하여 일관되게 사용하여야 한다. 
- 개발 초기 도메인 모델을 설계할 때는 도메인에 반드시 필요한 부분만 우선적으로 설계한다.
  - 예를 들어, 회원 도메인을 설계하면서 '로그인 기능에는 소셜 로그인이 되어야하고, 2차 인증이 필요하다.'와 같은  
    디테일적인 부분을 처음부터 정의할 필요는 없다. 

## 엔티티(Entity)
- 도메인 모델을 만들 때 사용하는 패턴
- 도메인 안에 있는 대상이나 개념
- 고유한 식별자(identity)를 가지고 이를 통해 개별적으로 구분됨.
- 생명주기(life cycle)를 가진다. 시간의 흐름에 따라 상태가 변경될 수 있다.
### 엔티티 식별자
- 고유성: 두 개의 엔티티가 같은 값을 가지면 안 된다.
- 불변성: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다.
  - 참조 정합성을 훼손하고, 연관관계를 깨뜨린다.
- 비즈니스적인 의미로부터 디커플링 되는 것이 낫다.
  - 자연 키 대신 **인조 키(대리 키) 사용**

## 애그리거트(Aggregate)
- 데이터 변경의 목적을 위해 하나의 단위로 취급되는 연관된 객체의 클러스터이다.
- 루트(root)와 경계(boundary)를 가진다.
- 특징
  - 데이터 변경 시 하나의 단위로 취급: 데이터 변경의 일관성을 유지한다.
  - 루트를 통한 접근 제어: 외부 객체는 루트 엔티티에만 참조를 가질 수 있다.
  - 데이터 일관성 유지:
    - 경계 내의 어떤 변경 사항이 있을 때 전체 애그리거트의 모든 **불변식이 충족**되어야 한다.
    - 애그리거트를 넘어서는 불변식은 **이벤트나 배치** 등을 통해 특정 시간 내에 해결할 수 있다.
  - 검색 및 접근 방식: 리포지토리를 통해서 애그리거트 루트만 직접 얻을 수 있다.
    - 내부 엔티티는 루트로부터 연관관계를 통해서 접근한다.
- 목표
  - 일관성 유지: 객체 그룹에 적용되는 불변식을 유지하는 수단
  - 이해 용이성: 객체의 시작과 끝을 명확히 해서 모델을 더 쉽게 이해하게 한다.
  - 트랜잭션 및 동시성 관리: 트랜잭션 범위와 데이터 일관성 유지 방법 제공
  - 모델 단순화: 연관 관계 탐색을 제한하고 루트를 통해서만 접근하도록 해준다.
  - Factory와 Repository가 복잡한 생명주기 전환을 캡슐화하는 단위가 되도록 한다.
- 적용 방법
  - JPA의 cascading을 적절하게 활용한다.
  - 리포지토리는 애그리거트 단위로 만든다.
    - 스프링 데이터 JPA의 핵심 원칙
    - Repository<T, ID>: T = Aggregate Root
    - 리포지토리 리턴 타입은 애그리거트 루트
  - 가능하다면 하나의 트랜잭션에 하나의 애그리거트만 변경한다.
  - 다른 애그리거트의 참조는 애그리거트 루트에 대해서만 한다.
    - 연관관계 애그리거트 루트의 레퍼런스 대신 루트의 ID 값만 저장하기도 한다.
- 애그리거트의 설계와 적용의 어려움
  - 적절한 애그리거트 경계를 선택하는 것은 꽤 어려운 결정이다.
  - 개발하면서 애그리거트의 범위가 달라지기도 한다.
    - 대체로 작은 애그리거트가 될 가능성이 높다.
  - 성능에 부담을 주게 된다. (lazy loading의 도움이 필요)
  - 내부 엔티티로의 직접 접근이나 여러 애그리거트를 한 번에 조회하는 기능이 필요한 경우가 있다.
  - 도메인 이벤트와 최종적 일관성(eventual consistency)의 사용이 요구된다.

## 도메인 모델 패턴
- 도메인/비즈니스 로직을 구성하는 아키텍처 패턴의 한 가지
- 도메인 모델의 **속성과 행위를 모두 포함**하는 **도메인의 오브젝트 모델**이다.
- 오브젝트 모델이기 때문에 복잡한 연관 관계, 커스텀 속성, 상속 등을 사용할 수 있다.
- 트랜잭션 스크립트는 **하나의 업무절차(TX)**를 처리하기 위한 스크립트(메소드)를 만들고 비즈니스 로직을  
  **순서대로 코드**로 작성하는 방법
### 도메인 모델 패턴의 두 가지 스타일
- 단순 도메인 모델(Simple Domain Model): DB 설계와 유사, 테이블에 대해 하나의 도메인 오브젝트
- 풍성한 도메인 모델(Rich Domain Model): 상속, 전략, GoF 디자인 패턴, 연관 관계  
  복잡한 로직에 적합하지만 DB 매핑이 어려울 수 있다. -> 이걸 해결해주는 것이 JPA(ORM) 기술
  - JPA(ORM)이 매핑을 통해서 해결하려는 패러다임 불일치 문제
    - 세분성(Granularity) 불일치
    - 상속(Subtype) 불일치
    - 정체성(Identity) 불일치
    - 연관(Association) 불일치
    - 데이터 탐색(Navigation) 불일치
### 도메인 로직의 API 개발
- 도메인 모델 패턴은 트랜잭션 스크립트처럼 작업 단위의 절차형 API를 만들기 어렵다.
- 도메인 로직의 명확한 **작업 단위 API**를 제공하는 **어플리케이션 서비스**가 필요

---

## Null 안정성 확보
- Spring Framework가 제공하는 @NonNull 어노테이션을 활용하면 IDE가 Null 체크를 할 수 있다.
- gradle plugin인 spotbugs를 활용하여 빌드 과정에서 에러를 발생시킬 수 있다.
- package-info에 @NonNullApi를 정의하여 기본적으로 null을 허용하지 않도록 한 뒤 @Nullable 어노테이션을 활용할 수 있다.

---

## 값 객체(Value Object)
- 도메인 모델에서 식별자가 필요하지 않고 속성/값으로만 구별되는 오브젝트
- 엔티티가 너무 많은 책임을 가지는 것을 방지하고 특정 속성 관련 행위를 분리해서 엔티티를 더 집중된 상태로 유지하게 한다.
- 원시 타입보다는 도메인 개념을 더 명시적으로 나타내서 모델의 명확성을 높인다. 

---

## 아키텍처
- 시스템의 기본적인 구조를 정의한다.
- 설계 결정의 기반이 되는 핵심적인 개념으로 기본 구성 요소와 상호 관계, 제약 조건, 원칙 등을 포함한다.
### 계층형 아키텍쳐(Layered Architecture)
- 서브 시스템을 계층(layers)으로 구조화 하는 아키텍처 스타일이다.
- 계층은 사용 관계로 연결된다
- 사용 관계는 일반적으로 단방향이어야 한다는 핵심 제약이 있다.
  - 상위 계층이 하위 계층의 서비스를 사용하는 하향식 흐름을 가진다.
- 각 계층이 하위 계층의 내부 작동 방식을 알지 못하고 제한된 인터페이스만 사용하도록 한다. (계층 격리 Layers of Isolation)
  - 어떤 레이어의 변경이 다른 레이어의 컴포넌트에게 가능한 영향을 주지 않도록 해야 한다.
- 3계층 아키텍처(UI/Presentation, Domain/Business Logic, Data/Persistence/Infra)
- 3or4계층 아키텍처(Presentation, Application Service, Domain, Infra)
### 헥사고날 아키텍처(포트와 어댑터 아키텍처)
- 계층형 아키텍처의 단방향 비대칭 구조가 아닌 대칭형(symmetric) 아키텍처
- 특징과 혜택
  - **운영 시스템에 연결되지 않고** 애플리케이션 테스트
  - UI 디테일이나 기술 정보가 **도메인 로직 안으로 노출되지 않도록** 보호한다. 반대도 마찬가지
  - 컴포넌트를 각각 개발하고 연결하는 방식으로 **큰 시스템을 분리**할 수 있다.
  - 시간이 지나면서 **외부 연결을 다른 것으로 변경**할 수 있다.
  - 기술 요소를 제거했기 때문에 **도메인 설계에 집중**할 수 있다.
- 헥사곤의 내부: 쉽게 변하지 않는, 중요한 도메인 로직을 담은 코어 애플리케이션
  - 도메인 로직을 가진 트랜잭션 스크립트
  - 애플리케이션 서비스와 도메인 모델 패턴을 따라서 만든 도메인
- 헥사곤의 외부: 헥사곤과 상호작용(interaction)하는 모든 것 - 액터(Actor)
  - 사용자, 브라우저, CLI, 기계, 다른 시스템
  - 운영 환경, DB, 메시징 시스템, 메일 시스템, 원격 서비스
  - 테스트
- 헥사곤을 부르는 여러 이름
  - 헥사곤
  - **애플리케이션**
  - 앱(App)
  - 코어 시스템
  - SuD(System under Development)
  - SuT(System under Test)
- 포트(port)
  - 애플리케이션이 외부 세계와 의도(intention)를 가지고 상호작용 하는 아이디어를 캡처한 것
  - 단순히 데이터를 주고받는 것이 아니라, 명확한 목적과 방향을 가지고 외부와 연결된다.
  - 인터페이스
    - Lollipop: 기능 제공 인터페이스(Provided Interface)
    - Socket: 기능 요구 인터페이스(Required Interface)
- 어댑터(Adapter)
  - 어플리케이션의 포트를 액터가 직접 연결할 수 없을 때 **인터페이스의 변환**하는 역할
    - 브라우저를 통해 애플리케이션의 회원 가입 포트의 기능 제공 인터페이스를 사용하기 위해 **회원 가입 기능 제공 인터페이스**를  
      사용하는 **웹 컨트롤러** 어댑터를 만든다.
    - 애플리케이션이 가진 회원 정보 저장 포터의 기능 요구 인터페이스로 DB와 직접 연결할 수 없으면 **기능 요구 인터페이스**를  
      구현한 **리포지토리 어댑터**를 만든다.
- 헥사고날 아키텍처의 비대칭성
  - 애플리케이션이 제공하는 기능을 사용하는 액터와 이를 위한 어댑터
    - primary actor, primary adapter
    - driving actor, driving adapter
  - 애플리케이션이 동작하는데 필요한 기능을 제공하는 액터와 이를 위한 어댑터
    - secondary actor, secondary adapter
    - driven actor, driven adapter
- 헥사고날 아키텍처가 요구하는 것
  - 애플리케이션은 모든 외부와의 상호작용을 위해서 provided interface와 required interface를 정의한다.
  - 애플리케이션과 상호작용 하는 액터는 런타임에 구성되어야 한다.
  - 애플리케이션은 **액터에 대한 코드 의존성**을 가지면 안 된다
  - 액터는 **정의된 포트를 통해서만** 연결해야 한다.
  - 포트의 인터페이스에는 **기술 의존성을 가지지 않는다.**
- 오해
  - 애플리케이션 내부에 도메인 계층을 만들어야 한다.
    - 헥사고날 아키텍처는 애플리케이션 **내부 구현에 대한 원칙이나 요구사항이 없다.**
    - 도메인 계층을 포함하는 아키텍처는 클린 아키텍처이다.
    - 헥사고날 아키텍처는 클린 아키텍처, 어니언(onion) 아키텍처가 아니다.
  - 헥사고날 아키텍처 패키지 구조를 따라야 한다.
    - 헥사고날 아키텍처가 **요구하는 패키지 구조는 없다.**
    - 애플리케이션과 어댑터 패키지를 분리하는 것은 바람직하다.
    - 포트를 구분된 패키지에 두는 것을 권장한다.
  - 포트는 UseCase라는 접미사를 사용한다
    - **포트의 의도**를 담은 이름을 사용하면 된다.
    - For+~ing 스타일의 권장 네이밍이 이씨만 이를 따를 필요는 없다.
  - 애플리케이션에는 도메인 모델만 넣고 JPA 엔티티 등은 어댑터에 둬야 한다.
    - 애플리케이션 코드와 포트 인터페이스가 **외부 기술에 의존하지 않으면** 된다.
- 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조
  - 도메인 계층, 애플리케이션 계층, 어댑터 계층
  - 외부에서 내부로 향하는 일종의 계층 구조
  - 코드의 의존 방향은 내부로만 향한다. (어댑터 -> 애플리케이션 -> 도메인) 단, 사용의 흐름은 비대칭적이다.
- DDD의 아키텍처는?
  - 4개의 계층형 아키텍처: Eric Evans
  - **헥사고날 아키텍처: Vaugn Vernon**
- 헥사고날 아키텍처와 애그리거트
  - **애그리거트 단위로 애플리케이션(헥사곤)을 구성**하는 방법이 유용하다.
  - 다른 애그리거트로의 접근은 애플리케이션 포트를 통해서 ID를 전달하는 방식으로
    - 애플리케이션 내부 리포지토리에서 루트 엔티티를 조회하는 방식으로 이루어지게 강제할 수 있다.
  - 도메인 이벤트와 리스너를 이용해 애그리거트 사이의 작업을 연결할 수도 있다.

---

## 테스트
### Record로 테스트 만들 때 의존성 주입 방법
- `@TestConstructor` 사용
- `test.resources.junit-platform.properties`에 `spring.test.constructor.autowire.mode=all`추가
### MockedStatic 사용 시 주의점
- 반드시 `try-with-resource` 구문을 사용하여 closing 해줘야한다.

---

## 유효성 검사
- 도메인 모델은 도메인의 규칙에 해당하는 최소한의 검증이 필요하다.
- Application Layer가 중요한 방어막이 되는 것이 좋다.
## JSR-303 Bean Validation
- 제공하지 않는 검증이 필요한 경우에는 커스텀 어노테이션을 만들거나 검증 로직을 만들어 검증해야 한다.

---

## SpringData 와 JPA
- JPA를 사용할 때 다음과 같이 코드를 작성하는 것이 일반적이다.
``` java
  public Member activate(Long memberId) {
      Member member = memberRepository.findById(memberId).orElseThrow(() -> new IllegalArgumentException("회원을 찾을 수 없습니다. id: " + memberId));

      member.activate();

      return member;
  }
```
- 그러나 SpringData를 사용할 때는 다음과 같이 사용해야 한다.
``` java
  public Member activate(Long memberId) {
      Member member = memberRepository.findById(memberId).orElseThrow(() -> new IllegalArgumentException("회원을 찾을 수 없습니다. id: " + memberId));

      member.activate();

      return memberRepository.save(member);
  }
```
- JPA에는 `persist()`, `merge()`만이 존재한다. `save()`는 SpringData가 지원하는 JPA를 사용하는 것이다.
- 따라서 SpringData를 사용하는 방법으로 사용해야 하는데, 이유는 다음과 같다.
  - SpringData는 JPA만을 위한 기술이 아니다. Repository Abstraction을 제공하기 위해 여러 데이터 저장 기술을 추상화 한 것  
    따라서, 다른 종류의 저장소 기술을 사용할 때와 동일한 방식을 따라서 사용하는 것을 공식문서에서 권한다.
  - Event Publication, Auditing을 위해 필요하다.

### JPA 기술의 정체성
- ORM: 패러다임이 다른 관계형 DB와 객체지향 모델의 **불일치를 해결**하는 기술
- JPA의 기술적 목표는 자바 애플리케이션 개발자가 관계형 데이터베이스를 관리하기 위해 자바 도메인 모델을 활용할 수 있는
  객체/관계 매핑 기능을 제공하는 것.
- JPA의 엔티티는 경량 영속 도메인 오브젝트

---
## 추천 도서
- pattern of enterprise application architecture - 마틴 파울러